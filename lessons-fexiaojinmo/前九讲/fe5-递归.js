//递归

//递归简而言之就是一个函数调用本身或者两个函数相互调用
//我们只讨论第一种情况
//需要注意的是，递归是一个比较难以理解的概念
//看不懂， 不理解， 太正常了
//这需要时间， 不要急着出斧头强行非要搞懂

//注意，接下来的例子都只是例子而已，实际上不会这么写代码
//递归有适用的场景，但不会用来求解阶乘这样的事情，
//只是为了简化描述才用这个例子
//n! = n * (n-1)!
//当 n = 0, 阶乘为 1（规定）
//可以用递归编写以下的代码
var fac = function(n) {
    // 如果 n 是 0， 则返回 1
    // 这是递归终止的条件， 必须要有， 否则无限递归了
    if(n == 0) {
        return 1
    }else {
        // 如果 n 不为 0 ，则返回 n * fac(n-1)
        // 这时候 n 是已知的， fac(n-1) 需要计算
        // 于是代码进入下一重世界开始计算
        return n * fac(n-1)
    }
}

log('递归阶乘', fac(5))
//运行，输出如下
//递归阶乘 120
/*
return 5 * fac(4)
           4 * fac(3)
               3 * fac(2)
                   2 * fac(1)
                       1 * fac(0)
                           1
*/

// 斐波那契数列
// fib (n) = fib(n-2) + fib(n-1)
//当 n 等于 1 2 的时候， fib(n) 为 1
// 1 1 2 3 5 8 13 21 34 55 89 ...
//所以 可以用递归 编写下面的代码
var fib = function(n) {
    // 如果 n 是 1 或者 2， 则返回 1 作为结果
    // 这是终止条件, 必须要有，否则无限递归了
    if (n == 1 || n == 2) {
        return 1
    } else {
        // 如果 n 不为 1 和 2，返回 fib(n-2) + fib(n-1)
        // 这时候 fib(n-2) fib(n-1) 需要计算
        // 于是代码进入下一重世界开始计算
        return fib(n-2) + fib(n-1)
    }
}

log('递归fib', fib(6))
log('递归fib', fib(7))
//运行结果 8
//运行结果 13
/*
fib(6) = fib(4)                        + fib (5)
         fib(2) + fib(3)                   fib(4) + fib(3)
         1      +fib(1) + fib(2)           3      +   2
                   1    +  1
*/
 
