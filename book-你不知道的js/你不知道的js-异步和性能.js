// 第一章
// 异步：现在与将来
//
// js语言很重要的一点：如何表达和控制持续一段时间的程序行为
//
// 指的不是 for 循环这样的过程，而是指有的程序，一部分现在运行， 而另一部分则在将来运行——
// 现在和将来之间有段间隙，在这段间隙中，程序没有活跃执行。
//
// 实际上，所有重要的程序（特别是JavaScript 程序）都需要通过这样或那样的方法来管理
// 这段时间间隙，这时可能是:
// 在等待用户输入、从数据库或文件系统中请求数据、通过网络发送数据并等待响应，
// 或者是在以固定时间间隔执行重复任务（比如动画）
//
// 在这些场景中，我们需要管理这段时间间隙的状态。
//
// 事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。
//
// 异步编程，以前总是局限于 回调函数，但是随着发展，我们需要更强大、更合理的异步方法。
// --------------------------------------------------------------------------------
//
// 在探讨各种新出现的JavaScript 异步编程技术之前，我们首先需要深入理解异步的概念及其在JavaScript 中的运作模式。
//
// 1.1　分块的程序
// 可以把JavaScript 程序写在单个.js 文件中，但是这个程序几乎一定是由多个块构成的。这
// 些块中只有一个是现在执行，其余的则会在将来执行。最常见的块单位是函数。
//
// 大多数JavaScript 新手程序员都会遇到的问题是：程序中将来执行的部分并不一定在现在
// 运行的部分执行完之后就立即执行。
// 换句话说，现在无法完成的任务将会异步完成，因此并不会出现人们本能地认为会出现的或希望出现的阻塞行为。
// --------------------------------------------------------------------------------
// 考虑：
function result(data) {
    console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", result ); // 关键在于回调是否立即调用；影响result结果

a++;
// 这段代码会打印出0（同步回调调用）还是1（异步回调调用）呢？这要视情况而定。
//
// 你可以看出Zalgo 的不确定性给JavaScript 程序带来的威胁。所以听上去有点傻的“不要
// 放出Zalgo”实际上十分常用，并且也是有用的建议。永远要异步。
//
// 如果你不确定关注的API 会不会永远异步执行怎么办呢？可以创建一个类似于这个“验证
// 概念”版本的asyncify(..) 工具：

function asyncify(fn) {
    var orig_fn = fn,
    intv = setTimeout( function(){
        intv = null;
        if (fn) fn();
    }, 0 );

    fn = null;
    return function() {
        // 触发太快，在定时器intv触发指示异步转换发生之前？
        if (intv) {
            fn = orig_fn.bind.apply(
                orig_fn,
                // 把封装器的this添加到bind(..)调用的参数中，
                // 以及克里化（currying）所有传入参数
                [this].concat( [].slice.call( arguments ) )
            );
        }
        // 已经是异步
        else {
            // 调用原来的函数
            orig_fn.apply( this, arguments );
        }
    };
}

// 可以像这样使用asyncify(..)：
function result(data) {
    console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", asyncify( result ) ); // 修饰器函数

a++;

// 现在，不管这个Ajax 请求已经在缓存中并试图对回调立即调用，还是要从网络上取得，进而在
// 将来异步完成，这段代码总是会输出1，而不是0——因为修饰后 result(..) 只能异步调用，这意味
// 着a++ 会在result(..) 之前运行。
//
// 好啊，又“解决”了一个信任问题！但这是低效的，而且也会带来膨胀的重复代码，使你的项目变得笨重。
//
// 这就是回调的故事，讲了一遍又一遍。它们可以实现所有你想要的功能，但是你需要努力才行。
// 这些努力通常比你追踪这样的代码能够或者应该付出的要多得多。
//
// 可能现在你希望有内建的API 或其他语言机制来解决这些问题。最终，ES6 带着一些极好
// 的答案登场了，所以，继续读下去吧！
// --------------------------------------------------------------------------------
//
// 2.5 小结
// 回调函数是JavaScript 异步的基本单元。但是随着JavaScript 越来越成熟，对于异步编程领
// 域的发展，回调已经不够用了。
//
// 第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流
// 程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码
// 是坏代码，会导致坏bug。
//
// 我们需要一种更同步、更顺序、更阻塞的的方式来表达异步，就像我们的大脑一样。
//
// 第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三
// 方（通常是不受你控制的第三方工具！）来调用你代码中的continuation(续篇)。这种控制转移导
// 致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。(提前或延后的调用，或不调用)
//
// 可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更
// 笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到bug 的影响才会
// 被发现。(例如我们的 asyncify 修饰器)
//
// 我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可
// 以复用，且没有重复代码的开销。
//
// 我们需要比回调更好的机制。到目前为止，回调提供了很好的服务，但是未来的JavaScript
// 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。
// --------------------------------------------------------------------------------
//
// 第 3 章
// Promise
//
// 在第2 章里，我们确定了通过回调表达程序异步和管理并发的两个主要缺陷：缺乏顺序性
// 和可信任性。既然已经对问题有了充分的理解，那么现在是时候把注意力转向可以解决这
// 些问题的模式了。


var x, y = 2;
console.log( x + y ); // NaN <-- 因为x还没有设定

// 让我们回到x + y 这个算术运算。设想如果可以通过一种方式表达：“把x 和y 加起来，
// 但如果它们中的任何一个还没有准备好，就等待两者都准备好。一旦可以就马上执行加运算。”
//
// 回调

function add(getX,getY,cb) {
    var x, y;
    getX(function(xVal){
        x = xVal;
        // 两个都准备好了？
        if(y != undefined) {
            cb( x + y ); // 发送和
        }
    });

    getY(function(yVal){
        y = yVal;
        // 两个都准备好了？
        if(x != undefined) {
            cb( x + y ); // 发送和
        }
    });
}

// fetchX() 和fetchY()是同步或者异步函数
add( fetchX, fetchY, function(sum){
    console.log( sum ); // 是不是很容易？
});

// 在这段代码中，我们把x 和y 当作未来值，并且表达了一个运算add(..)。这个运算（从
// 外部看）不在意x 和y 现在是否都已经可用。换句话说，它把现在和将来归一化了，因此
// 我们可以确保这个add(..) 运算的输出是可预测的。
//
// 通过使用这个时间上一致的add(..)——从现在到将来的时间，它的行为都是一致的——
// 大大简化了对这段异步代码的追踪。
//
// 说得更直白一些就是，为了统一处理现在和将来，我们把它们都变成了将来，即所有的操
// 作都成了异步的。
//
//
// 2. Promise 值

function add(xPromise,yPromise) {
    // Promise.all([ .. ])接受一个promise数组并返回一个新的promise，
    // 这个新promise等待数组中的所有promise完成
    return Promise.all( [xPromise, yPromise] )
    // 这个promise决议之后，我们取得收到的X和Y值并加在一起
    .then( function(values){
        // values是来自于之前决议的promisei的消息数组
        return values[0] + values[1];
    } );
}

// fetchX()和fetchY()返回相应值的promise，可能已经就绪，
// 也可能以后就绪
add( fetchX(), fetchY() )

// 我们得到一个这两个数组的和的promise
// 现在链式调用 then(..)来等待返回promise的决议
.then( function(sum){
    console.log( sum ); // 这更简单！
} );

// 这段代码中有两层Promise。
//
// fetchX() 和fetchY() 是直接调用的，它们的返回值（promise ！）被传给add(..)。这些
// promise 代表的底层值的可用时间可能是现在或将来，但不管怎样，promise 归一保证了行
// 为的一致性。我们可以按照不依赖于时间的方式追踪值X 和Y。它们是未来值。
//
// 第二层是add(..)（通过Promise.all([ .. ])）创建并返回的promise。我们通过调用
// then(..) 等待这个promise。add(..) 运算完成后，未来值sum 就准备好了，可以打印出
// 来。我们把等待未来值X 和Y 的逻辑隐藏在了add(..) 内部。
//
// 通过Promise，调用then(..) 实际上可以接受两个函数，第一个用于完成情况（如前所
// 示），第二个用于拒绝情况：

add( fetchX(), fetchY() )
.then(
    // 完成处理函数
    function(sum) {
        console.log( sum );
    },
    // 拒绝处理函数
    function(err) {
        console.error( err ); // 烦！
    }
);


// 从外部看，由于Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以
// Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成（组合），而不
// 用关心时序或底层的结果。
//
// Promise 是一种封装和组合未来值的易于复用的机制。
