function foo() {
    function bar(a) {
        i = 3; // 修改for 循环所属作用域中的i
        console.log( a + i );
    }
    for (var i=0; i<10; i++) {
        bar( i * 2 ); // 糟糕，无限循环了！
    }
}

foo();
// bar(..) 内部的赋值表达式i = 3 意外地覆盖了声明在foo(..) 内部for 循环中的i。

/**在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐
   藏”起来，外部作用域无法访问包装函数内部的任何内容。*/
var a = 2;

function foo() { // <-- 添加这一行
    var a = 3;
    console.log( a ); // 3
} // <-- 以及这一行

foo(); // <-- 以及这一行
console.log( a ); // 2

/**虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，
   必须声明一个具名函数foo()，意味着foo 这个名称本身“污染”了所在作用域（在这个!!!!!!!!
   例子中是全局作用域）。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其
   中的代码。*/

/**如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，
   这将会更加理想。*/

var a = 2;

(function foo(){ // <-- 添加这一行
    var a = 3;
    console.log( a ); // 3
})(); // <-- 以及这一行

console.log( a ); // 2

/**首先，包装函数的声明以(function... 而不仅是以function... 开始。尽管看上去这并不
   是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一
   个标准的函数声明来处理。*/

// 函数声明和函数表达式之间最重要的区别是它们的 名称标识符 将会绑定在何处。

/**比较一下前面两个代码片段。第一个片段中foo 被绑定在所在作用域中，可以直接通过
   foo() 来调用它。第二个片段中foo 被绑定在函数表达式自身的函数中而不是所在作用域中*/!!!!!

/**换句话说，(function foo(){ .. }) 作为函数表达式意味着foo 只能在.. 所代表的位置中
   被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作
   用域。*/ 调用自身

// 函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript 的语法中这是非法的。
(function() {
	console.log('函数表达式可以是匿名的');
})
// 运行结果是一个 函数表达式！！！！！！！！！！！！！！！！！
ƒ () {
	console.log('函数表达式可以是匿名的');
}

(function() {
	console.log('函数表达式可以是匿名的');
})()
// 运行结果 函数表达式可以是匿名的；立即执行  IIFE
/**由于函数被包含在一对( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个  !!!!
   ( ) 可以立即执行这个函数，比如(function foo(){ .. })()。第一个( ) 将函数变成表
   式，第二个( ) 执行了这个函数。*/

/**相较于传统的IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔
   细观察其中的区别。第一种形式中函数表达式被包含在( ) 中，然后在后面用另一个() 括
   号来调用。第二种形式中用来调用的() 括号被移进了用来包装的( ) 括号中。
   这两种形式在功能上是一致的。选择哪个全凭个人喜好。 */

// IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去; 依赖注入

var a = 2;

(function IIFE( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );

console.log( a ); // 2
/** 我们将window 对象的引用传递进去，但将参数命名为global，因此在代码风格上对全局
    对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传
    递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非
    常有帮助的。*/ ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

function() {
	console.log('函数声明不可以匿名');
}
// 运行结果 报错
Uncaught SyntaxError: Unexpected token (

// 对于函数表达式你最熟悉的场景可能就是回调参数了，比如：
setTimeout( function() {
    console.log("I waited 1 second!");
}, 1000 );
// 这叫作匿名函数表达式，因为function().. 没有 名称标识符
// 匿名函数有几个缺点 1. 看不到函数名，调试困难 2.引用自身？？？ 3.可理解性

// 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函
// 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
    console.log( "I waited 1 second!" );
}, 1000 );
